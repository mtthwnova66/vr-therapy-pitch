<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Synaeon - AI-Powered VR Therapy</title>
  <style>
    body {
      margin: 0;
      background: linear-gradient(135deg, #0a0a23, #1a1a3d);
      font-family: 'Arial', sans-serif;
      color: #fff;
      overflow-x: hidden;
    }
    #immersive-canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 5;
      opacity: 0.4; /* Subtle backdrop */
    }
    .container {
      position: relative;
      z-index: 10;
      max-width: 1200px;
      margin: 20px auto;
      padding: 20px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 16px;
      text-align: center;
    }
    h1 { font-size: 2rem; }
    p { font-size: 1.2rem; }
    #audio-controls {
      position: fixed;
      bottom: 20px;
      left: 20px;
      z-index: 1000;
      display: flex;
      align-items: center;
      background: rgba(255, 255, 255, 0.1);
      padding: 8px 15px;
      border-radius: 30px;
    }
    #audio-toggle {
      background: #0071e3;
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #audio-toggle svg { width: 20px; height: 20px; }
    .audio-status {
      margin-left: 10px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <canvas id="immersive-canvas"></canvas>
  <div id="audio-controls">
    <button id="audio-toggle" aria-label="Toggle Background Music">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M11 5L6 9H2v6h4l5 4V5z"></path>
        <path class="sound-wave" d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
      </svg>
    </button>
    <span class="audio-status">Music: Off</span>
  </div>
  <main class="container">
    <h1>AI-Powered VR Therapy</h1>
    <p>Experience real-time, adaptive, and clinically effective therapy that transforms mental health treatment.</p>
    <p>Look aroundâ€”you should see slow-moving, hallucinogenic alien shapes (orbs and tentacles), grass with white dust at the bottom, and hear cosmic music when you toggle the audio button.</p>
  </main>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded - initializing...');

      // Canvas Setup
      const canvas = document.getElementById('immersive-canvas');
      const ctx = canvas.getContext('2d');
      if (!ctx) {
        console.error('Canvas context not supported');
        return;
      }
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      console.log('Canvas initialized:', canvas.width, 'x', canvas.height);

      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        console.log('Canvas resized:', canvas.width, 'x', canvas.height);
      });

      // Audio Setup
      let bgMusic;
      window.audioPlaying = false;
      try {
        bgMusic = new Howl({
          src: ['https://freesound.org/data/previews/182/182617_3165007-lq.mp3'], // Deep space drone
          html5: true,
          volume: 0.5,
          loop: true,
          preload: true,
          onload: () => console.log('Audio loaded successfully'),
          onloaderror: (id, err) => console.error('Audio load failed:', err),
          onplayerror: (id, err) => console.error('Audio play failed:', err)
        });
      } catch (e) {
        console.error('Audio initialization failed:', e);
      }

      const audioToggle = document.getElementById('audio-toggle');
      const audioStatus = document.querySelector('.audio-status');

      audioToggle.addEventListener('click', () => {
        window.audioPlaying = !window.audioPlaying;
        if (window.audioPlaying) {
          try {
            bgMusic.play();
            audioStatus.textContent = 'Music: On';
            audioToggle.style.background = '#34c759';
            document.querySelector('.sound-wave').style.opacity = 1;
            console.log('Music playing');
          } catch (e) {
            console.error('Music playback failed:', e);
            window.audioPlaying = false;
            audioStatus.textContent = 'Music: Error';
          }
        } else {
          bgMusic.stop();
          audioStatus.textContent = 'Music: Off';
          audioToggle.style.background = '#0071e3';
          document.querySelector('.sound-wave').style.opacity = 0;
          console.log('Music stopped');
        }
      });

      // Unlock audio on first interaction (browser policy)
      document.body.addEventListener('click', function unlockAudio() {
        if (!window.audioPlaying && bgMusic && bgMusic.state() === 'loaded') {
          bgMusic.play().catch(() => {});
          bgMusic.stop();
          console.log('Audio unlocked');
        }
        document.body.removeEventListener('click', unlockAudio);
      });

      // Entities and Grass
      const entities = [];
      const entityCount = 5;
      const particles = [];
      const particleCount = 30;

      function createEntity() {
        return {
          x: Math.random() * canvas.width,
          y: Math.random() * (canvas.height * 0.8),
          size: Math.random() * 40 + 20,
          speedX: (Math.random() - 0.5) * 0.1,
          speedY: (Math.random() - 0.5) * 0.1,
          hue: Math.random() * 360,
          type: Math.random() < 0.5 ? 'orb' : 'tentacular',
          tendrils: Math.random() < 0.5 ? null : Array(4).fill().map(() => ({
            length: Math.random() * 30 + 20,
            angle: Math.random() * Math.PI * 2,
            speed: Math.random() * 0.02 + 0.01
          })),
          satellites: Math.random() >= 0.5 ? null : []
        };
      }

      function createParticle() {
        return {
          x: Math.random() * canvas.width,
          y: canvas.height - (Math.random() * 50),
          size: Math.random() * 2 + 1,
          speedY: -(Math.random() * 0.3 + 0.1),
          opacity: Math.random() * 0.3 + 0.1
        };
      }

      for (let i = 0; i < entityCount; i++) entities.push(createEntity());
      for (let i = 0; i < particleCount; i++) particles.push(createParticle());
      console.log('Entities initialized:', entities.length, 'Particles:', particles.length);

      function updateEntities(time) {
        entities.forEach(entity => {
          entity.x += entity.speedX;
          entity.y += entity.speedY;
          entity.hue += 0.5; // Hallucinogenic color shift
          if (entity.hue > 360) entity.hue -= 360;

          if (entity.x < -entity.size) entity.x = canvas.width + entity.size;
          if (entity.x > canvas.width + entity.size) entity.x = -entity.size;
          if (entity.y < -entity.size) entity.y = canvas.height * 0.8 + entity.size;
          if (entity.y > canvas.height * 0.8) entity.y = -entity.size;

          if (entity.satellites && Math.random() < 0.02) {
            entity.satellites.push({
              x: entity.x,
              y: entity.y,
              angle: Math.random() * Math.PI * 2,
              distance: entity.size * 0.5,
              speed: Math.random() * 0.05 + 0.02,
              life: 100
            });
          }
          if (entity.satellites) {
            entity.satellites = entity.satellites.filter(s => {
              s.angle += s.speed;
              s.life--;
              s.x = entity.x + Math.cos(s.angle) * s.distance;
              s.y = entity.y + Math.sin(s.angle) * s.distance;
              return s.life > 0;
            });
          }

          if (entity.tendrils) {
            entity.tendrils.forEach(t => {
              t.angle += t.speed * Math.sin(time * 0.001);
            });
          }
        });

        particles.forEach(p => {
          p.y += p.speedY;
          p.opacity -= 0.003;
          if (p.y < canvas.height * 0.8 || p.opacity <= 0) {
            Object.assign(p, createParticle());
          }
        });
      }

      function drawGrassAndDust() {
        const grassHeight = canvas.height * 0.1;
        const gradient = ctx.createLinearGradient(0, canvas.height - grassHeight, 0, canvas.height);
        gradient.addColorStop(0, 'rgba(34, 139, 34, 0.5)');
        gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, canvas.height - grassHeight, canvas.width, grassHeight);
        console.log('Grass drawn at:', canvas.height - grassHeight);

        particles.forEach(p => {
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fillStyle = `rgba(255, 255, 255, ${p.opacity})`;
          ctx.fill();
        });
      }

      function drawEntities(time) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrassAndDust();

        entities.forEach(entity => {
          ctx.save();
          ctx.translate(entity.x, entity.y);

          if (entity.type === 'orb') {
            ctx.beginPath();
            const radius = entity.size + Math.sin(time * 0.002) * 5;
            ctx.arc(0, 0, radius, 0, Math.PI * 2);
            const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius);
            gradient.addColorStop(0, `hsla(${entity.hue}, 90%, 60%, 0.6)`);
            gradient.addColorStop(1, `hsla(${entity.hue + 60}, 90%, 50%, 0)`);
            ctx.fillStyle = gradient;
            ctx.fill();

            if (entity.satellites) {
              entity.satellites.forEach(s => {
                ctx.beginPath();
                ctx.arc(s.x - entity.x, s.y - entity.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = `hsla(${entity.hue + 30}, 90%, 70%, ${s.life / 100})`;
                ctx.fill();
              });
            }
          } else {
            entity.tendrils.forEach(t => {
              ctx.beginPath();
              ctx.moveTo(0, 0);
              const endX = Math.cos(t.angle) * t.length;
              const endY = Math.sin(t.angle) * t.length;
              ctx.lineTo(endX, endY);
              ctx.strokeStyle = `hsla(${entity.hue}, 90%, 60%, 0.5)`;
              ctx.lineWidth = entity.size / 15;
              ctx.stroke();
            });
          }

          ctx.restore();
        });
        console.log('Entities drawn:', entities.length);
      }

      function animate(time) {
        updateEntities(time);
        drawEntities(time);
        requestAnimationFrame(animate);
      }

      requestAnimationFrame(animate);
      console.log('Animation started');
    });
  </script>
</body>
</html>
